<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>until.red</title>
  <meta name="description" content="You were never supposed to find this.">
  <meta property="og:title" content="until.red ‚Äì Countdown" />
  <meta property="og:description" content="You were never supposed to find this." />
  <meta property="og:image" content="red.jpg" />
  <meta property="og:url" content="https://until.red" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="until.red ‚Äì Countdown" />
  <meta name="twitter:description" content="You were never supposed to find this." />
  <meta name="twitter:image" content="red.jpg" />
  <link rel="icon" type="image/jpeg" href="red.jpg" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>

body {
            margin: 0;
            padding: 0;
            background: black;
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }
        
        #glyph-grid {
            display: grid;
            width: 100vw;
            height: 100vh;
            gap: 0;
            font-size: 16px;
            line-height: 1;
        }
        
        #glyph-grid span {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #962815;
        }
        
        .animate-pulse {
            animation: pulse 1s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { opacity: 0.4; }
            to { opacity: 1; }
        }
        
        .saying-text {
            color: #ffffff;
            font-weight: bold;
        }
        
        .countdown-text {
            color: #ffff00;
            font-weight: bold;
        }
  </style>
</head>
<body class="bg-black text-red-600 h-screen w-screen overflow-hidden relative">
  <div id="glyph-grid" class="absolute inset-0 grid text-4xl font-mono pointer-events-none animate-[glow_3s_ease-in-out_infinite] text-center place-items-center"></div>

  
  

<script>

  
   const sayings = [
            "Be still and know.",
            "The veil thins.",
            "Every eye shall see.",
            "The trumpet has already sounded.",
            "There is no more time.",
            "Let those who have ears hear."
        ];
        const glyphs = [
  '‚à¥', '‚üü', '‚Ü∫', '‚ßó', 'Œî', 'Ã∏',
  '‚òç', '‚üÅ', '‚ú¶', '‚ò≤', '‚ò∑',
  'üúÉ', 'üúÅ', '‚ßñ', '‚ßò', '‚ßô', 'üúî',
  '‚ü≤', '‚´Ω', 'üùÆ', '‚ôæ'
];

        let currentSayingIndex = 0;
        let revealProgress = 0;
        let state = 'revealing';
        let holdCounter = 0;
        let gridDimensions = { cols: 0, rows: 0 };

        function updateCountdownText() {
            const targetDate = new Date("2025-06-23T00:00:00Z").getTime();
            const now = new Date().getTime();
            const distance = targetDate - now;
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            return `${days}d ${hours}h ${minutes}m ${seconds}s`;
        }

        function generateRandomGlyph() {
            return glyphs[Math.floor(Math.random() * glyphs.length)];
        }

        function calculateGridDimensions() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const glyphPixelSize = 20; // Smaller for better fit
            const cols = Math.floor(width / glyphPixelSize);
            const rows = Math.floor(height / glyphPixelSize);
            return { cols, rows };
        }

        function fitTextToWidth(text, maxWidth) {
            if (text.length <= maxWidth) {
                return text;
            }
            
            // Try to break at word boundaries
            const words = text.split(' ');
            let result = '';
            
            for (let word of words) {
                if ((result + word).length <= maxWidth) {
                    result += (result ? ' ' : '') + word;
                } else {
                    break;
                }
            }
            
            // If we couldn't fit any complete words, truncate
            if (!result && maxWidth > 3) {
                result = text.substring(0, maxWidth - 3) + '...';
            } else if (!result) {
                result = text.substring(0, maxWidth);
            }
            
            return result;
        }

        function fillDynamicGlyphGrid() {
            const grid = document.getElementById('glyph-grid');
            const dimensions = calculateGridDimensions();
            
            // Only rebuild grid if dimensions changed significantly
            if (Math.abs(dimensions.cols - gridDimensions.cols) > 2 || 
                Math.abs(dimensions.rows - gridDimensions.rows) > 2) {
                gridDimensions = dimensions;
                grid.innerHTML = '';
                grid.style.gridTemplateColumns = `repeat(${dimensions.cols}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${dimensions.rows}, 1fr)`;
            }

            const { cols, rows } = dimensions;
            const centerRow = Math.floor(rows / 2);
            const centerCol = Math.floor(cols / 2);

            // Get texts and ensure they fit
            const countdownText = updateCountdownText();
            const maxTextWidth = Math.floor(cols * 0.8); // Use 80% of available width
            const fittedCountdown = fitTextToWidth(countdownText, maxTextWidth);
            
            const sayingText = sayings[currentSayingIndex];
            const fittedSaying = fitTextToWidth(sayingText, maxTextWidth);
            
            const countdownStartCol = Math.max(0, centerCol - Math.floor(fittedCountdown.length / 2));
            const sayingStartCol = Math.max(0, centerCol - Math.floor(fittedSaying.length / 2));

            // Clear existing content if grid wasn't rebuilt
            if (grid.children.length > 0) {
                Array.from(grid.children).forEach(span => {
                    if (!span.classList.contains('saying-text') && !span.classList.contains('countdown-text')) {
                        span.textContent = generateRandomGlyph();
                    }
                });
            }

            // Create grid if empty
            if (grid.children.length === 0) {
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const span = document.createElement('span');
                        span.textContent = generateRandomGlyph();
                        grid.appendChild(span);
                    }
                }
            }

            // Update saying row
            const sayingRowStart = (centerRow - 1) * cols;
            for (let i = 0; i < fittedSaying.length; i++) {
                const spanIndex = sayingRowStart + sayingStartCol + i;
                if (spanIndex >= 0 && spanIndex < grid.children.length) {
                    const span = grid.children[spanIndex];
                    
                    if (state === 'revealing' && i < revealProgress) {
                        span.textContent = fittedSaying[i];
                        span.className = 'animate-pulse saying-text';
                    } else if (state === 'hold') {
                        span.textContent = fittedSaying[i];
                        span.className = 'animate-pulse saying-text';
                    } else {
                        span.textContent = generateRandomGlyph();
                        span.className = '';
                    }
                }
            }

            // Update countdown row
            const countdownRowStart = centerRow * cols;
            for (let i = 0; i < fittedCountdown.length; i++) {
                const spanIndex = countdownRowStart + countdownStartCol + i;
                if (spanIndex >= 0 && spanIndex < grid.children.length) {
                    const span = grid.children[spanIndex];
                    span.textContent = fittedCountdown[i];
                    span.className = 'animate-pulse countdown-text';
                }
            }

            // Handle animation state
            if (state === 'revealing') {
                revealProgress++;
                if (revealProgress >= fittedSaying.length) {
                    state = 'hold';
                    holdCounter = 0;
                }
            } else if (state === 'hold') {
                holdCounter++;
                if (holdCounter >= 3) { // Hold for 3 seconds
                    currentSayingIndex = (currentSayingIndex + 1) % sayings.length;
                    revealProgress = 0;
                    state = 'revealing';
                }
            }
        }

        // Initialize
        fillDynamicGlyphGrid();
        setInterval(fillDynamicGlyphGrid, 1000);
        
        // Handle resize with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                gridDimensions = { cols: 0, rows: 0 }; // Force rebuild
                fillDynamicGlyphGrid();
            }, 250);
        });
</script>


  
</body>
</html>
