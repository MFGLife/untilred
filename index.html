<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>until.red</title>
  <meta name="description" content="You were never supposed to find this.">
  <meta property="og:title" content="until.red ‚Äì Countdown" />
  <meta property="og:description" content="You were never supposed to find this." />
  <meta property="og:image" content="red.jpg" />
  <meta property="og:url" content="https://until.red" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="until.red ‚Äì Countdown" />
  <meta name="twitter:description" content="You were never supposed to find this." />
  <meta name="twitter:image" content="red.jpg" />
  <link rel="icon" type="image/jpeg" href="red.jpg" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      height: 100vh;
    }
    
    #glyph-grid {
      display: grid;
      width: 100vw;
      height: 100vh;
      gap: 0;
      font-size: 16px;
      line-height: 1;
    }
    
    #glyph-grid span {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #962815;
    }
    
    .animate-pulse {
      animation: pulse 1s ease-in-out infinite alternate;
    }
    
    @keyframes pulse {
      from { opacity: 0.4; }
      to { opacity: 1; }
    }
    
    .saying-text {
      color: #ffffff;
      font-weight: bold;
    }
    
    .countdown-text {
      color: #ffff00;
      font-weight: bold;
    }

    .player-text {
      color: #dc2626;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .player-text:hover {
      color: #ef4444;
      transform: scale(1.1);
    }
    
    .player-text.active {
      color: #ffff00;
    }
    
    .control-text {
      color: #ffffff;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .control-text:hover {
      color: #ffff00;
      transform: scale(1.2);
    }

    /* Audio player styles */
    audio {
      display: none;
    }
  </style>
</head>
<body class="bg-black text-red-600 h-screen w-screen overflow-hidden relative">
  <div id="glyph-grid" class="absolute inset-0 grid text-4xl font-mono text-center place-items-center"></div>

  <!-- Hidden audio element -->
  <audio id="audio-player" preload="none"></audio>

<script>
const playlists = {
  "red.jpg": [
    "1.mp3",
    "2.mp3", 
    "3.mp3",
    "4.mp3"
  ]
};

// Audio player functionality
class AudioPlayer {
  constructor() {
    this.audio = document.getElementById('audio-player');
    this.currentTrack = null;
    this.isPlaying = false;
    this.volume = 0.7;
    this.currentTrackIndex = 0;
    this.playlist = [];
    
    this.initEventListeners();
  }
  
  initEventListeners() {
    this.audio.addEventListener('ended', () => {
      this.isPlaying = false;
      this.updatePlayPauseDisplay();
    });
    
    this.audio.addEventListener('error', () => {
      console.error('Audio error occurred');
    });
  }
  
  loadTrack(trackInfo, index) {
    this.currentTrack = trackInfo;
    this.currentTrackIndex = index;
    this.audio.src = trackInfo.url;
    this.audio.volume = this.volume;
    
    // Update active state
    this.updateActiveTrack();
  }
  
  togglePlayPause() {
    if (!this.currentTrack) return;
    
    if (this.isPlaying) {
      this.audio.pause();
      this.isPlaying = false;
    } else {
      this.audio.play().catch(e => {
        console.error('Playback failed:', e);
      });
      this.isPlaying = true;
    }
    this.updatePlayPauseDisplay();
  }
  
  stop() {
    this.audio.pause();
    this.audio.currentTime = 0;
    this.isPlaying = false;
    this.updatePlayPauseDisplay();
  }
  
  updatePlayPauseDisplay() {
    const playPauseEl = document.getElementById('play-pause-control');
    if (playPauseEl) {
      playPauseEl.textContent = this.isPlaying ? '‚è∏' : '‚ñ∂';
    }
  }
  
  updateActiveTrack() {
    // Update all track displays
    document.querySelectorAll('.track-item').forEach((el, index) => {
      if (index === this.currentTrackIndex) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    });
  }
  
  setPlaylist(playlist) {
    this.playlist = playlist;
  }
}

// Initialize audio player
const audioPlayer = new AudioPlayer();

// Glyph grid functionality
const sayings = [
  "Be still and know.",
  "The veil thins.",
  "Every eye shall see.",
  "The trumpet has already sounded.",
  "There is no more time.",
  "Let those who have ears hear."
];

const glyphs = [
  '‚à¥', '‚üü', '‚Ü∫', '‚ßó', 'Œî', 'Ã∏',
  '‚òç', '‚üÅ', '‚ú¶', '‚ò≤', '‚ò∑',
  'üúÉ', 'üúÅ', '‚ßñ', '‚ßò', '‚ßô', 'üúî',
  '‚ü≤', '‚´Ω', 'üùÆ', '‚ôæ'
];

let currentSayingIndex = 0;
let revealProgress = 0;
let state = 'revealing';
let holdCounter = 0;
let gridDimensions = { cols: 0, rows: 0 };

function updateCountdownText() {
  const targetDate = new Date("2025-06-23T00:00:00Z").getTime();
  const now = new Date().getTime();
  const distance = targetDate - now;
  
  if (distance < 0) {
    return "Time has come";
  }
  
  const days = Math.floor(distance / (1000 * 60 * 60 * 24));
  const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((distance % (1000 * 60)) / 1000);
  
  return `${days}${hours}${minutes}${seconds}`;
}

function generateRandomGlyph() {
  return glyphs[Math.floor(Math.random() * glyphs.length)];
}

function calculateGridDimensions() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  const glyphPixelSize = 20;
  const cols = Math.floor(width / glyphPixelSize);
  const rows = Math.floor(height / glyphPixelSize);
  return { cols, rows };
}

function fitTextToWidth(text, maxWidth) {
  if (text.length <= maxWidth) {
    return text;
  }
  
  const words = text.split(' ');
  let result = '';
  
  for (let word of words) {
    if ((result + word).length <= maxWidth) {
      result += (result ? ' ' : '') + word;
    } else {
      break;
    }
  }
  
  if (!result && maxWidth > 3) {
    result = text.substring(0, maxWidth - 3) + '...';
  } else if (!result) {
    result = text.substring(0, maxWidth);
  }
  
  return result;
}

function fillDynamicGlyphGrid() {
  const grid = document.getElementById('glyph-grid');
  const dimensions = calculateGridDimensions();
  
  if (Math.abs(dimensions.cols - gridDimensions.cols) > 2 || 
      Math.abs(dimensions.rows - gridDimensions.rows) > 2) {
    gridDimensions = dimensions;
    grid.innerHTML = '';
    grid.style.gridTemplateColumns = `repeat(${dimensions.cols}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${dimensions.rows}, 1fr)`;
  }

  const { cols, rows } = dimensions;
  const centerRow = Math.floor(rows / 2);
  const centerCol = Math.floor(cols / 2);

  const countdownText = updateCountdownText();
  const maxTextWidth = Math.floor(cols * 0.8);
  const fittedCountdown = fitTextToWidth(countdownText, maxTextWidth);
  
  const sayingText = sayings[currentSayingIndex];
  const fittedSaying = fitTextToWidth(sayingText, maxTextWidth);
  
  const countdownStartCol = Math.max(0, centerCol - Math.floor(fittedCountdown.length / 2));
  const sayingStartCol = Math.max(0, centerCol - Math.floor(fittedSaying.length / 2));

  // Create player elements in top row
  const tracks = playlists["red.jpg"];
  const playerElements = ['‚ñ∂', '‚èπ', ...tracks.map((_, i) => `${i+1}`), '‚ô™'];
  const playerStartCol = Math.max(0, Math.floor((cols - playerElements.length) / 2));

  if (grid.children.length > 0) {
    Array.from(grid.children).forEach(span => {
      if (!span.classList.contains('saying-text') && 
          !span.classList.contains('countdown-text') && 
          !span.classList.contains('player-text') &&
          !span.classList.contains('control-text')) {
        span.textContent = generateRandomGlyph();
      }
    });
  }

  if (grid.children.length === 0) {
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const span = document.createElement('span');
        span.textContent = generateRandomGlyph();
        grid.appendChild(span);
      }
    }
  }

  // Update player row (top row)
  for (let i = 0; i < playerElements.length; i++) {
    const spanIndex = playerStartCol + i;
    if (spanIndex >= 0 && spanIndex < cols && spanIndex < grid.children.length) {
      const span = grid.children[spanIndex];
      span.textContent = playerElements[i];
      
      if (i === 0) {
        // Play/Pause button
        span.className = 'control-text';
        span.id = 'play-pause-control';
        span.onclick = () => audioPlayer.togglePlayPause();
      } else if (i === 1) {
        // Stop button
        span.className = 'control-text';
        span.onclick = () => audioPlayer.stop();
      } else if (i < playerElements.length - 1) {
        // Track numbers
        const trackIndex = i - 2;
        span.className = 'player-text track-item';
        span.onclick = () => {
          audioPlayer.loadTrack({
            name: `Track ${trackIndex + 1}`,
            url: tracks[trackIndex]
          }, trackIndex);
        };
      } else {
        // Volume indicator
        span.className = 'control-text';
      }
    }
  }

  // Update saying row
  const sayingRowStart = (centerRow - 1) * cols;
  for (let i = 0; i < fittedSaying.length; i++) {
    const spanIndex = sayingRowStart + sayingStartCol + i;
    if (spanIndex >= 0 && spanIndex < grid.children.length) {
      const span = grid.children[spanIndex];
      
      if (state === 'revealing' && i < revealProgress) {
        span.textContent = fittedSaying[i];
        span.className = 'animate-pulse saying-text';
      } else if (state === 'hold') {
        span.textContent = fittedSaying[i];
        span.className = 'animate-pulse saying-text';
      } else {
        span.textContent = generateRandomGlyph();
        span.className = '';
      }
    }
  }

  // Update countdown row
  const countdownRowStart = centerRow * cols;
  for (let i = 0; i < fittedCountdown.length; i++) {
    const spanIndex = countdownRowStart + countdownStartCol + i;
    if (spanIndex >= 0 && spanIndex < grid.children.length) {
      const span = grid.children[spanIndex];
      span.textContent = fittedCountdown[i];
      span.className = 'animate-pulse countdown-text';
    }
  }

  // Handle animation state
  if (state === 'revealing') {
    revealProgress++;
    if (revealProgress >= fittedSaying.length) {
      state = 'hold';
      holdCounter = 0;
    }
  } else if (state === 'hold') {
    holdCounter++;
    if (holdCounter >= 3) {
      currentSayingIndex = (currentSayingIndex + 1) % sayings.length;
      revealProgress = 0;
      state = 'revealing';
    }
  }
}

// Initialize everything
audioPlayer.setPlaylist(playlists["red.jpg"]);
fillDynamicGlyphGrid();
setInterval(fillDynamicGlyphGrid, 1000);

// Handle resize with debouncing
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    gridDimensions = { cols: 0, rows: 0 };
    fillDynamicGlyphGrid();
  }, 250);
});
</script>

</body>
</html>